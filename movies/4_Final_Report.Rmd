---
title: "An Exploratory Data and Network Analysis of Movies"
author: Clarice, Daven, Lucia, Christopher and Indurain
date: September 6, 2019
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
#content {
    background: #fcfcfc;
    height: 100%;
    margin-left: 300px;
    max-width: 100% !important; 
    min-height: 100%;
}

img.image-thumb {
    width: 800px !important;
    border: 1px solid #CCC;
    padding: 2px;
}
```

## Introduction

In this report, we will be analysing a dataset from [Kaggle](https://www.kaggle.com/rounakbanik/the-movies-dataset#links.csv), which contains movies of different genres produced over a vast number of years. What makes this analysis interesting is that we can try and draw various conclusions based on a movie's popularity, directors or actors involved, year of production, and so forth. Moreover, we can construct various networks in an attempt to find meaningful and interesting results.
When inspecting a database of films from recent years, various interesting inferences are uncovered. A film may have a high rating yet low return on investment (ROI). Which genre would you guess is the most successful? Which actors do you think are the most popular? 


We have split our Exploratory Data Analysis into four main parts:

|  Section 	|                                                                                                                                                                                                                                                 	|
|---	|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| 1 	| Introducing the Data <br> - We first try to understand the data and look at its content.  |
| 2 	| Pre-Processing <br>- We look at what needs to be altered or removed from the dataset. <br>- We try clean any dirty text. <br>- We try to minimise the dataset's missing values.                                                                                    	|
| 3 	| Exploring the Data <br>- We conduct basic analysis on the dataset.  <br>- We explore genres. <br>- We explore movie popularity. <br>- We look at profit, gross, and return of interests with movies. <br>- We conduct more advanced analysis on the dataset.               	|
| 4 	| Network Analysis <br>- We measure the network (centrality, degree distribution, number of components, average degree) <br>- We use network measures to highlight certain nodes (actors) and see which measures of an actor will increase ratings and budgets.  	|                                                                                                                                  |

-----

## Admin

Before we start, let's keep this code chunk for importing the correct libraries and loading the appropriate dataset. We use pacman to load the following:

```{r message=FALSE, warning=FALSE}
pacman::p_load(rjson, jsonlite, DT,  RJSONIO, data.table, dplyr, compareDF, prettydoc, rmdformats, VIM, ggplot2, stringr, tidyr, plotly, RColorBrewer, formattable, corrplot, ggpubr, ngram, syuzhet, tm, wordcloud, sentimentr, reshape2, rlist, gplots, plsgenomics, ggrepel, GGally, rmdformats)
```

We import the dataset like this:
```{r}
movie_metadata <- read.csv("../data/movie_metadata.csv", sep=";")
```

In the next section we can introduce our dataset and look its content. 

-----

## Introducing The Dataset

This section of the report is quite essential for our analysis. We cannot make any interesting inferences from the dataset if we do not know what is contained within it. In this section we will try to understand exactly what we are dealing with. Thereafter, we can begin to draw interesting results. We have already read in our dataset called `movie_metadata`, so we can see the following:

The dataset contains 28 unique columns/variables, each of which are described in the table below:

Variable Name            | Description
-------------------------|----------------------------------------------
color                    | Specifies whether a movie is in black and white or color
director_name            | Contains name of the director of a movie
num_critic_for_reviews   | Contains number of critic reviews per movie
duration                 | Contains duration of a movie in minutes
director_facebook_likes  | Contains number of facebook likes for a director
actor_3_facebook_likes   | Contains number of facebook likes for actor 3
actor_2_name             | Contains name of 2nd leading actor of a movie
actor_1_facebook_likes   | Contains number of facebook likes for actor 1 
gross                    | Contains the amount a movie grossed in USD
genres                   | Contains the sub-genres to which a movie belongs
actor_1_name             | Contains name of the actor in lead role
movie_title              | Title of the Movie
num_voted_users          | Contains number of users votes for a movie
cast_total_facebook_likes| Contains number of facebook likes for the entire cast of a movie
actor_3_name             | Contains the name of the 3rd leading actor of a movie
facenumber_in_poster     | Contains number of actors faces on a movie poster
plot_keywords            | Contains key plot words associated with a movie
movie_imdb_link          | Contains the link to the imdb movie page
num_user_for_reviews     | Contains the number of user generated reviews per movie
language                 | Contains the language of a movie
country                  | Contains the name of the country in which a movie was made
content_rating           | Contains maturity rating of a movie
budget                   | Contains the amount of money spent in production per movie
title_year               | Contains the year in which a film was released
actor_2_facebook_likes   | Contains number of facebook likes for actor 2
imdb_score               | Contains user generated rating per movie
aspect_ratio             | Contains the size of the aspect ratio of a movie
movie_facebook_likes     | Number of likes of the movie on its Facebook Page


Furthermore, the dataset contains `5043` movies, spanning accross `96` years in 46 countries. There are `1693` unique director names and `5390` number of actors/actresses. Around `79%` of the movies are from the USA, `8%` from UK, and `13%` from other countries.

The structure of the dataset can also be used to understand our data. We can run the following code chunk to see its structure.

```{r}
# Get structure of dataset
str(movie_metadata)
```

In the next section we can start preparing the dataset for analyis by removing or simplifying some of the data.

-----

## Pre-Processing Data

In this part of the report we attempt to look for various things that may have a negative or insignificant impact on the inferences we make on the dataset. Once we have sufficiently cleaned and prepared the dataset, we can commence with drawing various conclusions from the graphs we generate. 


### Duplicate Rows

In `movie_metadata`, we have some duplicate rows, so we want to remove the 45 duplicated rows and keep the unique ones. 

```{r}
# find duplicated rows
sum(duplicated(movie_metadata))
```

```{r Remove Duplicates}
# Remove duplicated rows
movie_metadata <- movie_metadata[!duplicated(movie_metadata), ]
```

### Missing Values

Let's have a look at the number of NA values in our dataset:
```{r}
# Find NA values
colSums(sapply(movie_metadata, is.na))
```

To help visualise this, have a look at the following heatmap of the missing values:
```{r }
# Visualise Missing Values
missing.values <- aggr(movie_metadata, sortVars = T, prop = T, sortCombs = T, cex.lab = 1.5, cex.axis = .6, cex.numbers = 5, combined = F, gap = -.2)
```

#### Gross and Budget

Since `gross` and `budget` have too many missing values (874 and 488), and we want to keep these two variables for the following analysis, we can only delete rows with null values for gross and budget because imputation will not do a good job here.

```{r}
# Find NA values for gross and budget
movie_metadata <- movie_metadata[!is.na(movie_metadata$gross), ]
movie_metadata <- movie_metadata[!is.na(movie_metadata$budget), ]
dim(movie_metadata)
```

The difference in observations have decreased by `4998 - 3857 = 1141` which is luckily only `22.8%` of the previous total observations.
Let’s have a look at how many complete cases we have.

#### Content Rating

```{r}
# Look at all the different types of content ratings
table(movie_metadata$content_rating)
```

According to the history of naming these different content ratings, we find `M = GP = PG, X = NC-17`. We want to replace `M` and `GP` with `PG`, replace `X` with `NC-17`, because these two are what we use nowadays.

```{r}
movie_metadata$content_rating[movie_metadata$content_rating == 'M']   <- 'PG' 
movie_metadata$content_rating[movie_metadata$content_rating == 'GP']  <- 'PG' 
movie_metadata$content_rating[movie_metadata$content_rating == 'X']   <- 'NC-17'
```

We want to replace `Approved`, `Not Rated`, `Passed`, `Unrated` with the most common rating `R`.

```{r}
movie_metadata$content_rating[movie_metadata$content_rating == 'Approved']  <- 'R' 
movie_metadata$content_rating[movie_metadata$content_rating == 'Not Rated'] <- 'R' 
movie_metadata$content_rating[movie_metadata$content_rating == 'Passed']    <- 'R' 
movie_metadata$content_rating[movie_metadata$content_rating == 'Unrated']   <- 'R' 
movie_metadata$content_rating <- factor(movie_metadata$content_rating)
table(movie_metadata$content_rating)
```

Blanks should be taken as missing value. Since these missing values cannot be replaced with reasonable data, we delete these rows.

```{r}
# Remove rows with blank content ratings
movie_metadata <- movie_metadata[!(movie_metadata$content_rating %in% ""),]
```

### Delete (Some) Rows

```{r}
colSums(sapply(movie_metadata, is.na))
```

We remove `aspect_ratio` because 1 it has a lot of missing values and 2 we will not be looking into the impact that it has on other data (we assume that it doesn't). 

```{r}
# Remove aspect_ratio column
movie_metadata <- subset(movie_metadata, select = -c(aspect_ratio))
```

### Add a Column

#### Gross and Budget

We have gross and budget information. So let’s add two colums: profit and percentage return on investment for further analysis.

```{r}
# add profit and return of investment column
movie_metadata <- movie_metadata %>% 
  mutate(profit = gross - budget,
         return_on_investment_perc = (profit/budget)*100)
```

### Remove (Some) Columns

#### Colour

Next, we take a look at the influence of `colour` vs `black and white`. 

```{r}
# Get colour display types of movies
table(movie_metadata$color)
```

Since `3.4%`of the data is in black and white, we can remove the `color` column it. 

```{r}
# delete colour
movie_metadata <- subset(movie_metadata, select = -c(color))
```

#### Language

Let's have a look at the different languages contained within the dataset.

```{r}
# Look at different languages
table(movie_metadata$language)
```

Almost `95%` movies are in English, which means this variable is nearly constant. Let’s remove it.

#### Country

Next, we can look at the different types of countries.

```{r}
table(movie_metadata$country)
```

Around `79%` movies are from USA, `8%` from UK, `13%` from other countries. So we group other countries together to make this categorical variable with less levels: `USA`, `UK`, `Others`.

```{r}
levels(movie_metadata$country) <- c(levels(movie_metadata$country), "Others")
movie_metadata$country[(movie_metadata$country != 'USA')&(movie_metadata$country != 'UK')] <- 'Others' 
movie_metadata$country <- factor(movie_metadata$country)
table(movie_metadata$country)
```

Now that we've cleaned up our dataset, we can now continue to explore our data even further! In the next section we will be looking at genres, movie popularity, gross, profit, and many more other aspects pertinent to our data. 

-----

## Analysing Data

When inspecting a dataset of movies over the past few years, various interesting inferences can be uncovered. A movie may have a high rating yet low return on investment. Which genre is the most successful? Which actors are the most popular? These are some of the questions we aim to answer in this section.

We can start by performing basic analyis on our data. Thereafter, we delve a bit deeper into more specific parts of the dataset, in hopes of uncovering interesting observations.

### Basic Analysis

Let's first have a look at the number of movies that are produced over the years.

```{r }
ggplot(movie_metadata, aes(title_year)) +
  geom_bar() +
  labs(x = "Year movie was released", y = "Movie Count", title = "Number of Movies Released Per Year (1916 - 2016)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_vline(xintercept=c(1980), linetype="dotted")
```

From the graph, we see there aren’t many records of movies released before 1980. It’s better to remove those records because they might not be representative.

```{r}
movie_metadata <- movie_metadata[movie_metadata$title_year >= 1980,]
```

Let's have a look at the movie counts now:

```{r }
ggplot(movie_metadata, aes(title_year)) +
  geom_bar() +
  labs(x = "Year movie was released", y = "Movie Count", title = "Number of Movies Released Per Year (1980 - 2016)") +
  theme(plot.title = element_text(hjust = 0.5))
```

### Movie Genre Analysis

```{r include=FALSE}
  
# setting up plotly label, axis and text customizations
f1 <- list(
  family = "Old Standard TT, serif",
  size = 14,
  color = "grey"
)
f2 <- list(
  family = "Old Standard TT, serif",
  size = 10,
  color = "black"
)
a <- list(
  titlefont = f1,
  showticklabels = T,
  tickangle = -45,
  tickfont = f2
)

m <- list(
  l = 50,
  r = 50,
  b = 100,
  t = 100,
  pad = 4
)

# annotations for subplot
a1 <- list(x = 0.5, y = 1.0,
          showarrow = FALSE, 
          text = "Distribution of bugdet", 
          xanchor = "center", 
          xref = "paper", 
          yanchor = "bottom", 
          yref = "paper", 
          font = f1)
  
b1 <- list(x = 0.5, y = 1.0, 
           showarrow = FALSE, 
           text = "Distribution of gross", 
           xanchor = "center", 
           xref = "paper", 
           yanchor = "bottom", 
           yref = "paper",
           font = f1)
```

Now we can delve into more specific things regarding movies, like `genres`. 

#### Top Genres

```{r }
genre = movie_metadata['genres']
genre = data.frame(table(genre))
genre = genre[order(genre$Freq,decreasing=TRUE),]

# Top 20 genres with the most movies
ggplot(genre[1:20,], aes(x=reorder(factor(genre), Freq), y=Freq, alpha=Freq)) + 
  geom_bar(stat = "identity", fill="blue") + 
  geom_text(aes(label=Freq),hjust=1.2, size=3.5)+
  xlab("Genre") + 
  ylab("Number of Movies") + 
  ggtitle("Top 20 genres with the most movies") + 
  coord_flip()
```

#### Split Genres

As you can see, movies have multiple genres that its associated with. For analysis purposes, we choose to use the first word in the genre column, as this is likely the most accurate description.

```{r}
head(movie_metadata$genres)
```

Let's split the genres separated by "|" into 8 different columns.

```{r fig.height=5, fig.width=11, message=FALSE, warning=FALSE}
# Split on "|"
genres_split <- str_split(movie_metadata$genres, pattern="[|]", n=2)

# Create Matrix
genres_matrix <- do.call(rbind, strsplit(movie_metadata$genres, '[|]'))

# Dataframe of genres
genres_df <- as.data.frame(genres_matrix)
```

`genre_df` consists of 8 columns, each with different genres. Let's have a look at the frequency of all the genres. 

```{r }
# Collapse all genres into one column
genres_one_col <- gather(genres_df) %>% 
  select(value)

# Plot frequency of first column
genres_one_col %>%
  group_by(value) %>% 
  tally() %>% 
  filter(n >= 30) %>% 
  ggplot() +
  geom_bar(aes(x = value, y=n), stat="identity") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("Genre") +
  ylab("Frequency") +
  NULL
```
It is evident that the Drama and Comedy genre are the most popular to be produced. However, this does not mean that they are the most profitable, returning successful ROI’s. This will further be explored.


Previously we assumed that the first genre is the most applicable, therefore, we choose the first column as the genre for the movie and append it to the dataframe. 
```{r}
# Take old genres column away
movie_metadata <- subset(movie_metadata, select = -c(genres))

# Take first column of genres_df and add it to MAIN df
movie_metadata$genre <- genres_df$V1
```

How does this distribution look like over the years? Lets have a look at the frequency of genres between the period of 1980 and 2016.

```{r }
movie_metadata %>%
 group_by(title_year, genre) %>%
 summarise(count = n()) %>%
 ggplot(aes(title_year, as.factor(genre))) +
 geom_tile(aes(fill=count),colour="white") +
 scale_fill_gradient(low="light blue",high = "dark blue") +
 xlab("Year of Movie") +
 ylab("Genre of Movie") +
 ggtitle("Heat Map of Movie Genres Produced Over the Years") +
  theme(panel.background = element_blank())
```

The heat map allows us to see that the popular genres with high frequencys are constantly being produced more and more often over the years. It is evident by the darker shades of blue becomming more prominent in the latter years. 

#### Which Genres are Popular?

In our dataset we have Facebook Likes and IMDB scores associated with a movie. This can help give us an indication of how popular each genre is. 

```{r include=FALSE}
# creating a function for plotting histogram using facet wrap
facet_hist_plot <- function(x, xlabel, bwidth){
  
  hp <- ggplot(data = movie_metadata, mapping = aes(x = x))
  hp + geom_histogram(aes(fill = genre), binwidth = bwidth,
                      show.legend = F, 
                      color = "black", size = 0.2, 
                      alpha = 0.8) +
    xlab(xlabel) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text = element_text(size = 12, angle = 20),
          axis.title = element_text(size = 14, 
                                    family = "Times", 
                                    color = "darkgrey",
                                    face = "bold")) + 
    facet_wrap(~ genre, scales = "free_y", ncol = 4)    
  }
```

```{r}
# Add column for total facebook likes
movie_metadata$total_facebook_likes <- movie_metadata$director_facebook_likes + 
  movie_metadata$actor_3_facebook_likes + movie_metadata$actor_1_facebook_likes +
  movie_metadata$cast_total_facebook_likes + movie_metadata$actor_2_facebook_likes + 
  movie_metadata$movie_facebook_likes
```

```{r include=FALSE}
movie_metadata <- movie_metadata[!is.na(movie_metadata$total_facebook_likes), ]
```

```{r, fig.height = 4, fig.width = 6, }
# creating a data frame containing avg score, avg votes and avg fb likes
score_votes_likes <- movie_metadata %>% 
  group_by(genre) %>%
  summarise(count = n(),
            avg_score = round(mean(imdb_score), 1),
            avg_votes = mean(num_voted_users),
            avg_facebook_likes = mean(total_facebook_likes),
            avg_reviews = mean(num_user_for_reviews)) %>%
  filter(count > 10)

# arranging data frame by average score
arr_score <- arrange(score_votes_likes, desc(avg_facebook_likes))

as.data.frame(score_votes_likes)

```

##### Genres VS IMDB Scores

Observing the graphs below, various genres consist of an array of different ratings. However, niche genres are more consistent  with their ratings, including musical; thriller; romance and western.

```{r fig.height = 10, fig.width = 10, }  
# genre wise distribution of scores using a custom plot function  
facet_hist_plot(movie_metadata$imdb_score, 
                "Genre",
                bwidth = 0.1)+
  scale_x_continuous(breaks = seq(0, 9.3, 1)) 
``` 



```{r include=FALSE, }
# creating a function for ploting bar graphs
bar_plot <- function(data, x, y, info, xlabl, ylabl, title, 
                      deci = NULL, suf = NULL){
  if(is.null(suf)) suf <- ""
  if(is.null(deci)) deci <- 0
  b1 <- ggplot(data, aes(x = reorder(genre, x), 
                               y = y, 
                               text = paste("Genre:", genre,
                                            info, 
                                            round(y, deci), suf)))
  
  b1 + geom_bar(aes(fill = genre), stat = "identity", 
           show.legend = F, color = "black", size = 0.2,
           width = 0.7, alpha = 0.7) +
  xlab(xlabl) +
  ylab(ylabl) +
  ggtitle(title) +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title = element_text(size = 14, 
                                  color = "grey", family = "Times")) +
  scale_fill_brewer(palette = "Spectral")

ggplotly(tooltip = "text") %>%
  layout(margin = m, xaxis = a, yaxis = a)
}
```


```{r }
# plotting 10 highest rated genres 
bar_plot(arr_score[1:10,],
         arr_score[1:10,]$avg_score,
         arr_score[1:10,]$avg_score,
         "| Average Score:",
         "Genres",
         "Average IMDB Score",
         "Top 10 IMDB Scores Per Genre",
         deci = 1)
```

The graph above allows us to see that a less produced category, bibliography, possess the most positive ratings.

##### Genres VS Facebook Likes

Let's now have a look at the Facebook likes. 

```{r }

# plotting 10 highest rated genres 
bar_plot(arr_score[1:10,],
         arr_score[1:10,]$avg_facebook_likes,
         arr_score[1:10,]$avg_facebook_likes,
         "| Average Score:",
         "Genres",
         "Average Facebook Likes",
         "Top 10 Facebook Likes Per Genre",
         deci = 1)
```

Biography also produces the highest likes on facebook. From this information, should directors strive to create more biography's? This will be determined when looking at the ROI. 

### Popularity Analysis

IMDB ratings VS Movie Count

```{r }
ggplot(movie_metadata, aes(imdb_score)) +
 geom_histogram(bins = 50) +
 geom_vline(xintercept = mean(movie_metadata$imdb_score,na.rm = TRUE),colour = "blue") +
 ylab("Movie Count") +
 xlab("IMDB Rating") +
 ggtitle("IMDB Ratings for Movies") +
  ggplot2::annotate("text", label = "Mean IMDB rating",x = 6.2, y = 50, size = 3, colour = "yellow",angle=90)
```
It is evident from the histogram that the majority of movies are rated between 6-8 out of 10. If a movie has a lower rating, it is clearly very unpopular or very bad. If a movie has a higher rating, it is evidently fantastic.

Popularity over the years
```{r message=FALSE, }
#Creating the required subset of data 
movies_pop <- movie_metadata %>%
 select(title_year, movie_facebook_likes) %>%
 filter(title_year > 1980) %>%
 group_by(title_year) %>%
 summarise(avg = mean(movie_facebook_likes)) 

#Generating the popularity Vs time plot
 ggplot(movies_pop, aes(x = title_year, y = avg)) +
   geom_point() +
   geom_smooth() + 
   geom_vline(xintercept = c(1990,2004),colour = c("orange","blue")) +
   ylab("Mean Popularity Score") +
   xlab("Years") +
   ggplot2::annotate("text", label = "Facebook",x = 2003, y = 80, size = 3, colour = "blue",angle=90)+
   ggplot2::annotate("text", label = "IMDB",x = 1989, y = 80, size = 3, colour = "orange",angle=90)
```
<br>

A spike in popularity in 2004 is obvious owing to the fact that there is a clear rise in popularity score.The creation of facebook and the effect of social media influenced this. 

Facebook Likes VS IMDB Score
```{r}
movie_metadata %>%
  plot_ly(x = ~movie_facebook_likes, y = ~imdb_score, color = ~content_rating , mode = "markers", text = ~content_rating, alpha = 0.7, type = "scatter")
```
It is evident that as a movie has higher ratings, the number of likes on facebook increases. This is probably due to the fact that a critic giving a movie a good rating, will increase the want of people to see and find more out about the move. 

Top 20 directors with highest average IMDB score

When examinning the directors with the highest IMDB scores, the highest average rating is 8.4. This means that movies with higher ratings are either excellent and/or fluke occurences. 
```{r}
movie_metadata %>%
  group_by(director_name) %>%
  summarise(avg_imdb = mean(imdb_score)) %>%
  arrange(desc(avg_imdb)) %>%
  top_n(20, avg_imdb) %>%
  formattable(list(avg_imdb = color_bar("orange")), align = 'l')
```

The IMDB rating systen started in 1990’s. Social media platforms like Facebook had started in the mid 2000’s. Facebook influenced the number of rates per movie far higher than that of IMDB.
```{r}
#Performing operations on Movies Vote Count over the years
 movies_vote1 <- movie_metadata %>%
  select(title_year, num_voted_users) %>%
  group_by(title_year) %>%
  summarise(count = sum(num_voted_users)) 

 ggplot(movies_vote1, aes(x = title_year, y = count/1000)) +
   geom_bar( stat = "identity") +
   geom_vline(xintercept = c(1990,2004),colour = c("orange","blue")) +
   ylab("Vote count (in thousands)") +
   xlab("Years") +
   ggplot2::annotate("text", label = "Facebook",x = 2003, y = 160, size = 3, colour = "blue",angle=90) + 
   ggplot2::annotate("text", label = "IMDB",x = 1989, y = 160, size = 3, colour = "orange",angle=90)
```

Vote Counts VS IMDB score

```{r echo=T}
# breaking num_users_voted into 4 buckets 
movie_metadata$vote_bucket <- cut(movie_metadata$num_voted_users, 
                         c(0, 50000, 100000, 300000, 500000))
```


```{r  fig.height = 4, fig.width = 6, }
# plotting a boxplot for votes vs imdb_score  
bp <- na.omit(movie_metadata) %>% 
  ggplot(aes(x = vote_bucket, y = imdb_score)) +
  geom_boxplot(aes(fill = vote_bucket), alpha = 0.7,
               show.legend = F) +
  stat_summary(fun.y = mean, geom = "point",
               shape = 23) +
  coord_flip() +
  xlab("User Votes") +
  ylab("IMDB Score") +
  ggtitle("Box plot for User Votes vs IMDB Score") +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, 
                                  color = "darkgrey",
                                  family = "Times"))
ggplotly(bp) %>%
  layout(margin = m, 
        xaxis = a, 
        yaxis = a,
        legend = list(orientation = "h", size = 4,
                       bgcolor = "#E2E2E2",
                       bordercolor = "darkgrey",
                       borderwidth = 1,
                       x = 0,
                       y = -0.3)) 
```

```{r warning=FALSE, include=FALSE, fig.height = 4, fig.width = 6,}
# creating a function called scatter_plot for
# plotting scatter plots using ggplot and plotly

scatter_plot <- function(x, y, xlabel, ylabel, title,
                         text1, text2, text3,
                         alpha = NULL){
  if(is.null(alpha)) alpha <- 0.4
  gp <- ggplot(data = movie_metadata, mapping = aes(x = x, y = y,
                                          text = paste(text1, x,
                                                       text2, y,
                                                       text3, movie_title)))
  plot <- gp + geom_point(position = "jitter", 
                          show.legend = F, shape = 21, 
                          stroke = .2, alpha = alpha) + 
    xlab(xlabel) +
    ylab(ylabel) +
    ggtitle(title) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 12, face = "bold", 
                                    family = "Times", 
                                    color = "darkgrey")) 
  
  ggplotly(plot, tooltip = "text") %>%
    layout(m, xaxis = a, yaxis = a)
}
```


```{r fig.height = 4, fig.width = 6, }
# scatter plot for user votes vs imdb score
scatter_plot(movie_metadata$num_voted_users, movie_metadata$imdb_score, 
     "User Votes",
     "IMDB Score",
     "Scatter plot for User Votes vs IMDB Score",
     "User Votes:",
     "<br>IMDB Score:",
     "<br>Title:",
     alpha = 0.3)
```
From the above scatter plot, it is evident that the majority of movie ratings are close to the 7.5 point. 

```{r message=FALSE, warning=FALSE, include=FALSE}
# creating a function for plotting plotly line graph for title_year
line_graph <- function(data, y, name){
 
  scat_p1 <- plot_ly(data, x = ~title_year, y = ~ y, 
             name = name, type = 'scatter', mode = 'lines',
             line = list(color = sample(brewer.pal(11, "Spectral"), 1))) %>%
  layout(xaxis = list(title = "Title Year", zeroline = F,
                      showline = F, 
                      showticklabels = T),
         yaxis = list(title = "Average Score"),
         title = "Line Graph for Avg Score/Avg Votes/Avg User Review by Title Year", 
         font = list(family = "Serif", color = "grey"),
         legend = list(orientation = "h", size = 6,
                       bgcolor = "#E2E2E2",
                       bordercolor = "darkgrey",
                       borderwidth = 1),
         margin = m)
  scat_p1
}
```


Each line represents an average, for the imdb score, votes and user review. 
```{r fig.height = 6, fig.width = 10, }


# creating a data frame for average score, avg votes and, avg user reviews
# by title year
scat_year_score <- movie_metadata %>%
  group_by(title_year) %>%
  summarise(count = n(),
            IMDB_Score = round(mean(imdb_score),1),
            avg_votes = mean(num_voted_users),
            avg_user_review = round(mean(num_user_for_reviews)))

# plotting line graph for Avg score by title year 
lp1 <- line_graph(scat_year_score, 
                  scat_year_score$IMDB_Score, 
                  "Average Score")

# plotting line graph for Avg votes by title year
lp2 <- line_graph(scat_year_score, 
                  scat_year_score$avg_votes, 
                  "Average Votes")

# plotting line graph for Avg reviews by title year
lp3 <- line_graph(scat_year_score,
                  scat_year_score$avg_user_review,
                  "Average User Review") 


subplot(lp1, lp2, lp3, nrows = 3, heights = c(0.33, 0.33, 0.33))

```


### Profit | Gross | Return of Interest

```{r }
budget <- movie_metadata %>%
  select(movie_title, budget) %>%
  arrange(desc(budget)) %>%
  head(15)

x <- ggplot(budget, aes(x = reorder(movie_title, -desc(budget)), y = budget/1000000)) +
  geom_bar( stat = "identity")+ 
  theme(axis.text.x=element_text(hjust=1))+
  ggtitle("Movie Budgets")+
  xlab("")+
  ylab("Budget (in Millions)") + 
  coord_flip()

rev <- movie_metadata %>%
  select(movie_title, gross) %>%
  arrange(desc(gross)) %>%
  head(15)

y <- ggplot(rev, aes(x = (reorder(movie_title, -desc(gross))), y = gross/1000000)) +
  geom_bar( stat = "identity")+ 
  theme(axis.text.x=element_text(hjust=1))+
  ggtitle("Movie Gross")+
  xlab("")+
  ylab("Gross (in Millions)") + 
  coord_flip() 

ggarrange(x, y,
          labels = c("A", "B"),
          ncol = 1, nrow = 2)
```

Most Successful Directors based on Profit
```{r }
#Top 20 most successful directors
movie_metadata %>%
        group_by(director_name) %>%
  mutate(profit = gross - budget)%>%
select(director_name, budget, gross, profit) %>%
na.omit() %>% 
summarise(films = n(), budget = sum(as.numeric(budget)), gross = sum(as.numeric(gross)), profit = sum(as.numeric(profit))) %>%
mutate(avg_per_film = profit/films) %>%
arrange(desc(avg_per_film)) %>% 
top_n(20, avg_per_film) %>%
ggplot( aes(x = films, y = avg_per_film/1000000)) + 
geom_point(size = 1, color = "blue") + 
geom_text_repel(aes(label = director_name), size = 3, color = "blue") + 
xlab("Number of Films") + ylab("Avg Profit $millions") + 
ggtitle("Most Successful Directors")
```

Top 20 movies based on its Profit

```{r }
#Top 20 movies based on its Profit
movie_metadata %>% 
  filter(title_year %in% c(2000:2016)) %>%
  mutate(profit = gross - budget,
         return_on_investment_perc = (profit/budget)*100) %>%
  arrange(desc(profit)) %>% 
  top_n(20, profit) %>%
  ggplot(aes(x=budget/1000000, y=profit/1000000)) + 
  geom_point(size = 2) + 
  geom_smooth(size = 1) + 
  geom_text_repel(aes(label = movie_title), size = 3) + 
  xlab("Budget $million") + 
  ylab("Profit $million") + 
  ggtitle("20 Most Profitable Movies")
```

Top 20 movies based on its Return on Investment
```{r }
#Top 20 movies based on its Return on Investment
movie_metadata %>% 
  filter(budget >100000) %>%
  mutate(profit = gross - budget,
         return_on_investment_perc = (profit/budget)*100) %>%
  arrange(desc(profit)) %>% 
  top_n(20, profit) %>%
  ggplot(aes(x=budget/1000000, y=return_on_investment_perc)) + 
  geom_point(size = 2) + 
  geom_smooth(size = 1) + 
  geom_text_repel(aes(label = movie_title), size = 3) + 
  xlab("Budget $million") + 
  ylab("Percent Return on Investment") + 
  ggtitle("20 Most Profitable Movies based on its Return on Investment")
```

### Further Analysis

#### Commercial success Vs Critical acclaim
```{r }
movie_metadata %>%
  top_n(15, profit) %>%
  ggplot(aes(x = imdb_score, y = gross/10^6, size = profit/10^6, color = content_rating)) + 
  geom_point() + 
  geom_hline(aes(yintercept = 600)) + 
  geom_vline(aes(xintercept = 7.75)) + 
  geom_text_repel(aes(label = movie_title), size = 4) +
  xlab("Imdb score") + 
  ylab("Gross money earned in million dollars") + 
  ggtitle("Commercial success Vs Critical acclaim") +
  ggplot2::annotate("text", x = 8.5, y = 700, label = "High ratings \n & High gross") +
  theme(plot.title = element_text(hjust = 0.5))
```

#### Correlation Heatmap

```{r }
ggcorr(movie_metadata, label = TRUE, label_round = 2, label_size = 2.8, size = 2, hjust = .85) +
  ggtitle("Correlation Heatmap") +
  theme(plot.title = element_text(hjust = 0.5))
```

Based on the heatmap, we can see some high correlations (greater than 0.7) between predictors.

According to the highest correlation value 0.95, we find actor_1_facebook_likes is highly correlated with the cast_total_facebook_likes, and both actor2 and actor3 are also somehow correlated to the total. So we want to modify them into two variables: actor_1_facebook_likes and other_actors_facebook_likes.

There are high correlations among num_voted_users, num_user_for_reviews and num_critic_for_reviews.

#### Sentiment Analysis

```{r}
options(scipen = 999)
```

```{r}
IMDB <- read.csv("../data/real_deal.csv")

#Removing Duplicates
IMDB <- IMDB[!duplicated(IMDB), ]

#Removing White-Spaces and Special Characters
IMDB$movie_title <- gsub("Â", "", as.character(factor(IMDB$movie_title)))
IMDB$movie_title <- str_trim(IMDB$movie_title, side = "right")

IMDB <- subset(IMDB, select = -c(genres))

colSums(sapply(IMDB, is.na))
```

```{r }
#Plotting Facebook likes against IMDB score
ggplot(data = IMDB, aes(x = imdb_score, y = movie_facebook_likes)) +
  geom_point() +
  stat_smooth(method="lm")
```

```{r }
#Plotting Aspect Ratio against Facebook likes
IMDB %>% 
  filter(aspect_ratio==1.85 | aspect_ratio==2.35) %>%
  mutate(aspect_ratio=as.character((aspect_ratio))) %>%
  ggplot() +
  geom_point(aes(x=aspect_ratio, y=movie_facebook_likes))
```

```{r}
#Constructing Top 20
keywords_split <- str_split(IMDB$plot_keywords, pattern="[|]", n=5)

keywords_matrix <- do.call(rbind, strsplit(as.character(IMDB$plot_keywords), "[|]"))

keywords_df <- as.data.frame(keywords_matrix)

names(keywords_df) <- c("one", "two", "three", "four", "five")

keywords_one_col <- gather(keywords_df) %>% 
  select(value)

keywords_one_col_freq <- keywords_one_col %>%
  group_by(value) %>%
  tally()

top_20 <- keywords_one_col_freq %>%
  select(value, n) %>%
  top_n(20)


movies_with_keywords <- data.frame()
IMDB_keyword_movie <- data.frame()
```


```{r }
keywords_one_col %>%
  group_by(value) %>% 
  tally() %>% 
  filter(n > 30) %>% 
  ggplot() +
  geom_bar(aes(x = value, y=n), stat="identity") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) 

top_20
```


```{r}
#Placing Top 20 Words Against Movie Success

IMDB_true_false <- IMDB 
for (keyword in top_20$value) {
  IMDB_true_false <- cbind(IMDB_true_false, ifelse(str_detect(IMDB$plot_keywords, keyword), "TRUE", "FALSE"))
}

for (i in 1:20) {
  reference <- 27
  names(IMDB_true_false)[reference + i] <- top_20$value[i]  
}

truey <- data.frame()
for (keyword in top_20$value) {
  truey <- rbind(truey, IMDB_true_false %>%
                            filter(get(keyword) == TRUE) %>% select(movie_title, gross, imdb_score, movie_facebook_likes, plot_keywords)) %>%
    distinct(movie_title, .keep_all = T)
}



falsy <- data.frame()
for (keyword in top_20$value) {
  falsy <- rbind(falsy, IMDB_true_false %>%
                            filter(get(keyword) == FALSE) %>% select(movie_title, gross, imdb_score, movie_facebook_likes, plot_keywords)) %>%
    distinct(movie_title, .keep_all = T)
}
```

```{r}
truey <- truey %>%
  mutate(tri = "Top 20 Word")

falsy <- falsy %>%
  mutate(tri = "NOT Top 20 Word")

truey_falsy <- full_join(falsy, truey, by = c("movie_title", "gross", "imdb_score", "movie_facebook_likes", "plot_keywords"))

truey_falsy <- truey_falsy %>%
  mutate(tri = coalesce(tri.y, tri.x)) %>%
  select(movie_title, gross, imdb_score, movie_facebook_likes, plot_keywords, tri)

truey_falsy <-  truey_falsy %>%
  group_by(tri) %>%
  na.omit() %>%
  mutate(avg = mean(gross))

truey_falsy_graph <- summarise(truey_falsy, avg = mean(gross))
```

```{r}
truey_falsy_graph %>%
  ggplot() +
  geom_bar(aes(x = tri, y=avg, fill=tri), stat="identity", position="stack") +
  theme(axis.text.x = element_blank()) 
```


```{r}
#Sentiment

keywords_from_split <- data.frame(lapply(keywords_split, "length<-", max(lengths(keywords_split))))

#Creating a list of titles and years seperatored by "|"
titles <-  IMDB %>%
  select(movie_title)
years <- IMDB %>%
  select(title_year)

titles_years_list <- list()

for (x in 1:4998) {
  seperator="|"
  titles_years_list <- c(titles_years_list, paste(titles$movie_title[x], years$title_year[x], sep="|"))
}

#Renaming columns to movie names
movie_name_list <- IMDB$movie_title
names(keywords_from_split) <- titles_years_list

#Adding column to the begining
key_names <- c('key_word_1', 'key_word_2', 'key_word_3', 'key_word_4', 'key_word_5')
keywords_from_split <- cbind(test_keys = key_names, keywords_from_split)

#Moving columns to rows
keywords_from_split <- melt(keywords_from_split, id = "test_keys")

#Creating new column for year
keywords_from_split_matrix <- do.call(rbind, strsplit(as.character(keywords_from_split$variable), "[|]"))
keywords_from_split <- cbind(keywords_from_split, keywords_from_split_matrix)
names(keywords_from_split) <- c("Key #", "Combined", "Keyword", "Title", "Year")
keywords_from_split = keywords_from_split %>%
  select(`Key #`, Title, Year, Keyword)

#Replacing blank cells within keywords to NA's
keywords_from_split$Keyword[keywords_from_split$Keyword == ""] <- NA
#Removing rows containing NA's
keywords_from_split <- na.omit(keywords_from_split)

#All unique years
all_years <- keywords_from_split %>% select(Year)
all_years <- distinct(all_years)
all_years <- na.omit(all_years)
all_years <- all_years %>%
  filter(Year != "NA")

#Function for sentiment per year
yearly_sentiment <- function(year, df) {
  amount <- nrow(df %>%
    select(Year) %>%
    filter(Year == year))
  df <- df %>%
    filter(Year == year)
  sentiments <- get_nrc_sentiment(as.character(df[4]))
  for (i in 1:length(sentiments)) {
    sentiments[i] <- sentiments[i]/amount
  }
  year_sentiment <- cbind(year, sentiments)
  return (year_sentiment)
}

sentiments <- data.frame()

#For-loop to capture all years
for (i in all_years$Year) {
  sentiments <- rbind(sentiments,yearly_sentiment(i, keywords_from_split))
}

#Making years integers
sentiments$year <- strtoi(sentiments$year)

#Sort by year
sentiments <- sentiments[with(sentiments, order(year)), ]
#sentiments <- sentiments[order(year), ]

#Heatmap for sentiments
rnames <- sentiments[,1]
mat_sentiments <- data.matrix(sentiments[,2:ncol(sentiments)])
rownames(mat_sentiments) <- rnames
mat_sentiments <- t(mat_sentiments)

df_sentiment <-  as.data.frame(mat_sentiments)
names_emotions <- c("anger", "anticipation", "disgust","fear","joy","sadness","surprise","trust","negative","positive")

sentiments_graph <- cbind(names_emotions, df_sentiment)
```


```{r}
#Heatmap
heatmap.2(mat_sentiments, Rowv=NA, Colv=NA, scale="row", col=colorRampPalette(c("white","darkblue")),  margins=c(5,10), trace = "none")
```


```{r}
#Filtering sentiments graph
sentiments_graph_filter <- sentiments %>%
  filter(year >= 2000)

#Other graphs
# Showing trends between sentiment from the 2000's 
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = anger)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = anticipation)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = disgust)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = fear)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = joy)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = sadness)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = surprise)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = trust)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = negative)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = positive)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
```


-----

## Network Analysis









=======
---
title: "An Exploratory Data and Network Analysis of Movies"
author: Clarice, Daven, Lucia, Christopher and Indurain
date: September 6, 2019
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
#content {
    background: #fcfcfc;
    height: 100%;
    margin-left: 300px;
    max-width: 100% !important; 
    min-height: 100%;
}

img.image-thumb {
    width: 800px !important;
    border: 1px solid #CCC;
    padding: 2px;
}
```

## Introduction

In this report, we will be analysing a dataset from [Kaggle](https://www.kaggle.com/rounakbanik/the-movies-dataset#links.csv), which contains movies of different genres produced over a vast number of years. What makes this analysis interesting is that we can try and draw various conclusions based on a movie's popularity, directors or actors involved, year of production, and so forth. Moreover, we can construct various networks in an attempt to find meaningful and interesting results.
When inspecting a database of films from recent years, various interesting inferences are uncovered. A film may have a high rating yet low return on investment (ROI). Which genre would you guess is the most successful? Which actors do you think are the most popular? 


We have split our Exploratory Data Analysis into four main parts:

|  Section 	|                                                                                                                                                                                                                                                 	|
|---	|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| 1 	| Introducing the Data <br> - We first try to understand the data and look at its content.  |
| 2 	| Pre-Processing <br>- We look at what needs to be altered or removed from the dataset. <br>- We try clean any dirty text. <br>- We try to minimise the dataset's missing values.                                                                                    	|
| 3 	| Exploring the Data <br>- We conduct basic analysis on the dataset.  <br>- We explore genres. <br>- We explore movie popularity. <br>- We look at profit, gross, and return of interests with movies. <br>- We conduct more advanced analysis on the dataset.               	|
| 4 	| Network Analysis <br>- We measure the network (centrality, degree distribution, number of components, average degree) <br>- We use network measures to highlight certain nodes (actors) and see which measures of an actor will increase ratings and budgets.  	|                                                                                                                                  |

-----

## Admin

Before we start, let's keep this code chunk for importing the correct libraries and loading the appropriate dataset. We use pacman to load the following:

```{r message=FALSE, warning=FALSE}
pacman::p_load(rjson, jsonlite, DT,  RJSONIO, data.table, dplyr, compareDF, prettydoc, rmdformats, VIM, ggplot2, stringr, tidyr, plotly, RColorBrewer, formattable, corrplot, ggpubr, ngram, syuzhet, tm, wordcloud, sentimentr, reshape2, rlist, gplots, plsgenomics, ggrepel, GGally, rmdformats)
```

We import the dataset like this:
```{r}
movie_metadata <- read.csv("../data/movie_metadata.csv", sep=";")
```

In the next section we can introduce our dataset and look its content. 

-----

## Introducing The Dataset

This section of the report is quite essential for our analysis. We cannot make any interesting inferences from the dataset if we do not know what is contained within it. In this section we will try to understand exactly what we are dealing with. Thereafter, we can begin to draw interesting results. We have already read in our dataset called `movie_metadata`, so we can see the following:

The dataset contains 28 unique columns/variables, each of which are described in the table below:

Variable Name            | Description
-------------------------|----------------------------------------------
color                    | Specifies whether a movie is in black and white or color
director_name            | Contains name of the director of a movie
num_critic_for_reviews   | Contains number of critic reviews per movie
duration                 | Contains duration of a movie in minutes
director_facebook_likes  | Contains number of facebook likes for a director
actor_3_facebook_likes   | Contains number of facebook likes for actor 3
actor_2_name             | Contains name of 2nd leading actor of a movie
actor_1_facebook_likes   | Contains number of facebook likes for actor 1 
gross                    | Contains the amount a movie grossed in USD
genres                   | Contains the sub-genres to which a movie belongs
actor_1_name             | Contains name of the actor in lead role
movie_title              | Title of the Movie
num_voted_users          | Contains number of users votes for a movie
cast_total_facebook_likes| Contains number of facebook likes for the entire cast of a movie
actor_3_name             | Contains the name of the 3rd leading actor of a movie
facenumber_in_poster     | Contains number of actors faces on a movie poster
plot_keywords            | Contains key plot words associated with a movie
movie_imdb_link          | Contains the link to the imdb movie page
num_user_for_reviews     | Contains the number of user generated reviews per movie
language                 | Contains the language of a movie
country                  | Contains the name of the country in which a movie was made
content_rating           | Contains maturity rating of a movie
budget                   | Contains the amount of money spent in production per movie
title_year               | Contains the year in which a film was released
actor_2_facebook_likes   | Contains number of facebook likes for actor 2
imdb_score               | Contains user generated rating per movie
aspect_ratio             | Contains the size of the aspect ratio of a movie
movie_facebook_likes     | Number of likes of the movie on its Facebook Page


Furthermore, the dataset contains `5043` movies, spanning accross `96` years in 46 countries. There are `1693` unique director names and `5390` number of actors/actresses. Around `79%` of the movies are from the USA, `8%` from UK, and `13%` from other countries.

The structure of the dataset can also be used to understand our data. We can run the following code chunk to see its structure.

```{r}
# Get structure of dataset
str(movie_metadata)
```

In the next section we can start preparing the dataset for analyis by removing or simplifying some of the data.

-----

## Pre-Processing Data

In this part of the report we attempt to look for various things that may have a negative or insignificant impact on the inferences we make on the dataset. Once we have sufficiently cleaned and prepared the dataset, we can commence with drawing various conclusions from the graphs we generate. 


### Duplicate Rows

In `movie_metadata`, we have some duplicate rows, so we want to remove the 45 duplicated rows and keep the unique ones. 

```{r}
# find duplicated rows
sum(duplicated(movie_metadata))
```

```{r Remove Duplicates}
# Remove duplicated rows
movie_metadata <- movie_metadata[!duplicated(movie_metadata), ]
```

### Missing Values

Let's have a look at the number of NA values in our dataset:
```{r}
# Find NA values
colSums(sapply(movie_metadata, is.na))
```

To help visualise this, have a look at the following heatmap of the missing values:
```{r }
# Visualise Missing Values
missing.values <- aggr(movie_metadata, sortVars = T, prop = T, sortCombs = T, cex.lab = 1.5, cex.axis = .6, cex.numbers = 5, combined = F, gap = -.2)
```

#### Gross and Budget

Since `gross` and `budget` have too many missing values (874 and 488), and we want to keep these two variables for the following analysis, we can only delete rows with null values for gross and budget because imputation will not do a good job here.

```{r}
# Find NA values for gross and budget
movie_metadata <- movie_metadata[!is.na(movie_metadata$gross), ]
movie_metadata <- movie_metadata[!is.na(movie_metadata$budget), ]
dim(movie_metadata)
```

The difference in observations have decreased by `4998 - 3857 = 1141` which is luckily only `22.8%` of the previous total observations.
Let’s have a look at how many complete cases we have.

#### Content Rating

```{r}
# Look at all the different types of content ratings
table(movie_metadata$content_rating)
```

According to the history of naming these different content ratings, we find `M = GP = PG, X = NC-17`. We want to replace `M` and `GP` with `PG`, replace `X` with `NC-17`, because these two are what we use nowadays.

```{r}
movie_metadata$content_rating[movie_metadata$content_rating == 'M']   <- 'PG' 
movie_metadata$content_rating[movie_metadata$content_rating == 'GP']  <- 'PG' 
movie_metadata$content_rating[movie_metadata$content_rating == 'X']   <- 'NC-17'
```

We want to replace `Approved`, `Not Rated`, `Passed`, `Unrated` with the most common rating `R`.

```{r}
movie_metadata$content_rating[movie_metadata$content_rating == 'Approved']  <- 'R' 
movie_metadata$content_rating[movie_metadata$content_rating == 'Not Rated'] <- 'R' 
movie_metadata$content_rating[movie_metadata$content_rating == 'Passed']    <- 'R' 
movie_metadata$content_rating[movie_metadata$content_rating == 'Unrated']   <- 'R' 
movie_metadata$content_rating <- factor(movie_metadata$content_rating)
table(movie_metadata$content_rating)
```

Blanks should be taken as missing value. Since these missing values cannot be replaced with reasonable data, we delete these rows.

```{r}
# Remove rows with blank content ratings
movie_metadata <- movie_metadata[!(movie_metadata$content_rating %in% ""),]
```

### Delete (Some) Rows

```{r}
colSums(sapply(movie_metadata, is.na))
```

We remove `aspect_ratio` because 1 it has a lot of missing values and 2 we will not be looking into the impact that it has on other data (we assume that it doesn't). 

```{r}
# Remove aspect_ratio column
movie_metadata <- subset(movie_metadata, select = -c(aspect_ratio))
```

### Add a Column

#### Gross and Budget

We have gross and budget information. So let’s add two colums: profit and percentage return on investment for further analysis.

```{r}
# add profit and return of investment column
movie_metadata <- movie_metadata %>% 
  mutate(profit = gross - budget,
         return_on_investment_perc = (profit/budget)*100)
```

### Remove (Some) Columns

#### Colour

Next, we take a look at the influence of `colour` vs `black and white`. 

```{r}
# Get colour display types of movies
table(movie_metadata$color)
```

Since `3.4%`of the data is in black and white, we can remove the `color` column it. 

```{r}
# delete colour
movie_metadata <- subset(movie_metadata, select = -c(color))
```

#### Language

Let's have a look at the different languages contained within the dataset.

```{r}
# Look at different languages
table(movie_metadata$language)
```

Almost `95%` movies are in English, which means this variable is nearly constant. Let’s remove it.

#### Country

Next, we can look at the different types of countries.

```{r}
table(movie_metadata$country)
```

Around `79%` movies are from USA, `8%` from UK, `13%` from other countries. So we group other countries together to make this categorical variable with less levels: `USA`, `UK`, `Others`.

```{r}
levels(movie_metadata$country) <- c(levels(movie_metadata$country), "Others")
movie_metadata$country[(movie_metadata$country != 'USA')&(movie_metadata$country != 'UK')] <- 'Others' 
movie_metadata$country <- factor(movie_metadata$country)
table(movie_metadata$country)
```

Now that we've cleaned up our dataset, we can now continue to explore our data even further! In the next section we will be looking at genres, movie popularity, gross, profit, and many more other aspects pertinent to our data. 

-----

## Analysing Data

When inspecting a dataset of movies over the past few years, various interesting inferences can be uncovered. A movie may have a high rating yet low return on investment. Which genre is the most successful? Which actors are the most popular? These are some of the questions we aim to answer in this section.

We can start by performing basic analyis on our data. Thereafter, we delve a bit deeper into more specific parts of the dataset, in hopes of uncovering interesting observations.

### Basic Analysis

Let's first have a look at the number of movies that are produced over the years.

```{r }
ggplot(movie_metadata, aes(title_year)) +
  geom_bar() +
  labs(x = "Year movie was released", y = "Movie Count", title = "Number of Movies Released Per Year (1916 - 2016)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_vline(xintercept=c(1980), linetype="dotted")
```

From the graph, we see there aren’t many records of movies released before 1980. It’s better to remove those records because they might not be representative.

```{r}
movie_metadata <- movie_metadata[movie_metadata$title_year >= 1980,]
```

Let's have a look at the movie counts now:

```{r }
ggplot(movie_metadata, aes(title_year)) +
  geom_bar() +
  labs(x = "Year movie was released", y = "Movie Count", title = "Number of Movies Released Per Year (1980 - 2016)") +
  theme(plot.title = element_text(hjust = 0.5))
```

### Movie Genre Analysis

```{r include=FALSE}
  
# setting up plotly label, axis and text customizations
f1 <- list(
  family = "Old Standard TT, serif",
  size = 14,
  color = "grey"
)
f2 <- list(
  family = "Old Standard TT, serif",
  size = 10,
  color = "black"
)
a <- list(
  titlefont = f1,
  showticklabels = T,
  tickangle = -45,
  tickfont = f2
)

m <- list(
  l = 50,
  r = 50,
  b = 100,
  t = 100,
  pad = 4
)

# annotations for subplot
a1 <- list(x = 0.5, y = 1.0,
          showarrow = FALSE, 
          text = "Distribution of bugdet", 
          xanchor = "center", 
          xref = "paper", 
          yanchor = "bottom", 
          yref = "paper", 
          font = f1)
  
b1 <- list(x = 0.5, y = 1.0, 
           showarrow = FALSE, 
           text = "Distribution of gross", 
           xanchor = "center", 
           xref = "paper", 
           yanchor = "bottom", 
           yref = "paper",
           font = f1)
```

Now we can delve into more specific things regarding movies, like `genres`. 

#### Top Genres

```{r }
genre = movie_metadata['genres']
genre = data.frame(table(genre))
genre = genre[order(genre$Freq,decreasing=TRUE),]

# Top 20 genres with the most movies
ggplot(genre[1:20,], aes(x=reorder(factor(genre), Freq), y=Freq, alpha=Freq)) + 
  geom_bar(stat = "identity", fill="blue") + 
  geom_text(aes(label=Freq),hjust=1.2, size=3.5)+
  xlab("Genre") + 
  ylab("Number of Movies") + 
  ggtitle("Top 20 genres with the most movies") + 
  coord_flip()
```

#### Split Genres

As you can see, movies have multiple genres that its associated with. For analysis purposes, we choose to use the first word in the genre column, as this is likely the most accurate description.

```{r}
head(movie_metadata$genres)
```

Let's split the genres separated by "|" into 8 different columns.

```{r fig.height=5, fig.width=11, message=FALSE, warning=FALSE}
# Split on "|"
genres_split <- str_split(movie_metadata$genres, pattern="[|]", n=2)

# Create Matrix
genres_matrix <- do.call(rbind, strsplit(movie_metadata$genres, '[|]'))

# Dataframe of genres
genres_df <- as.data.frame(genres_matrix)
```

`genre_df` consists of 8 columns, each with different genres. Let's have a look at the frequency of all the genres. 

```{r }
# Collapse all genres into one column
genres_one_col <- gather(genres_df) %>% 
  select(value)

# Plot frequency of first column
genres_one_col %>%
  group_by(value) %>% 
  tally() %>% 
  filter(n >= 30) %>% 
  ggplot() +
  geom_bar(aes(x = value, y=n), stat="identity") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("Genre") +
  ylab("Frequency") +
  NULL
```
It is evident that the Drama and Comedy genre are the most popular to be produced. However, this does not mean that they are the most profitable, returning successful ROI’s. This will further be explored.


Previously we assumed that the first genre is the most applicable, therefore, we choose the first column as the genre for the movie and append it to the dataframe. 
```{r}
# Take old genres column away
movie_metadata <- subset(movie_metadata, select = -c(genres))

# Take first column of genres_df and add it to MAIN df
movie_metadata$genre <- genres_df$V1
```

How does this distribution look like over the years? Lets have a look at the frequency of genres between the period of 1980 and 2016.

```{r }
movie_metadata %>%
 group_by(title_year, genre) %>%
 summarise(count = n()) %>%
 ggplot(aes(title_year, as.factor(genre))) +
 geom_tile(aes(fill=count),colour="white") +
 scale_fill_gradient(low="light blue",high = "dark blue") +
 xlab("Year of Movie") +
 ylab("Genre of Movie") +
 ggtitle("Heat Map of Movie Genres Produced Over the Years") +
  theme(panel.background = element_blank())
```

The heat map allows us to see that the popular genres with high frequencys are constantly being produced more and more often over the years. It is evident by the darker shades of blue becomming more prominent in the latter years. 

#### Which Genres are Popular?

In our dataset we have Facebook Likes and IMDB scores associated with a movie. This can help give us an indication of how popular each genre is. 

```{r include=FALSE}
# creating a function for plotting histogram using facet wrap
facet_hist_plot <- function(x, xlabel, bwidth){
  
  hp <- ggplot(data = movie_metadata, mapping = aes(x = x))
  hp + geom_histogram(aes(fill = genre), binwidth = bwidth,
                      show.legend = F, 
                      color = "black", size = 0.2, 
                      alpha = 0.8) +
    xlab(xlabel) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text = element_text(size = 12, angle = 20),
          axis.title = element_text(size = 14, 
                                    family = "Times", 
                                    color = "darkgrey",
                                    face = "bold")) + 
    facet_wrap(~ genre, scales = "free_y", ncol = 4)    
  }
```

```{r}
# Add column for total facebook likes
movie_metadata$total_facebook_likes <- movie_metadata$director_facebook_likes + 
  movie_metadata$actor_3_facebook_likes + movie_metadata$actor_1_facebook_likes +
  movie_metadata$cast_total_facebook_likes + movie_metadata$actor_2_facebook_likes + 
  movie_metadata$movie_facebook_likes
```

```{r include=FALSE}
movie_metadata <- movie_metadata[!is.na(movie_metadata$total_facebook_likes), ]
```

```{r, fig.height = 4, fig.width = 6, }
# creating a data frame containing avg score, avg votes and avg fb likes
score_votes_likes <- movie_metadata %>% 
  group_by(genre) %>%
  summarise(count = n(),
            avg_score = round(mean(imdb_score), 1),
            avg_votes = mean(num_voted_users),
            avg_facebook_likes = mean(total_facebook_likes),
            avg_reviews = mean(num_user_for_reviews)) %>%
  filter(count > 10)

# arranging data frame by average score
arr_score <- arrange(score_votes_likes, desc(avg_facebook_likes))

as.data.frame(score_votes_likes)

```

##### Genres VS IMDB Scores

Observing the graphs below, various genres consist of an array of different ratings. However, niche genres are more consistent  with their ratings, including musical; thriller; romance and western.

```{r fig.height = 10, fig.width = 10, }  
# genre wise distribution of scores using a custom plot function  
facet_hist_plot(movie_metadata$imdb_score, 
                "Genre",
                bwidth = 0.1)+
  scale_x_continuous(breaks = seq(0, 9.3, 1)) 
``` 



```{r include=FALSE, }
# creating a function for ploting bar graphs
bar_plot <- function(data, x, y, info, xlabl, ylabl, title, 
                      deci = NULL, suf = NULL){
  if(is.null(suf)) suf <- ""
  if(is.null(deci)) deci <- 0
  b1 <- ggplot(data, aes(x = reorder(genre, x), 
                               y = y, 
                               text = paste("Genre:", genre,
                                            info, 
                                            round(y, deci), suf)))
  
  b1 + geom_bar(aes(fill = genre), stat = "identity", 
           show.legend = F, color = "black", size = 0.2,
           width = 0.7, alpha = 0.7) +
  xlab(xlabl) +
  ylab(ylabl) +
  ggtitle(title) +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title = element_text(size = 14, 
                                  color = "grey", family = "Times")) +
  scale_fill_brewer(palette = "Spectral")

ggplotly(tooltip = "text") %>%
  layout(margin = m, xaxis = a, yaxis = a)
}
```


```{r }
# plotting 10 highest rated genres 
bar_plot(arr_score[1:10,],
         arr_score[1:10,]$avg_score,
         arr_score[1:10,]$avg_score,
         "| Average Score:",
         "Genres",
         "Average IMDB Score",
         "Top 10 IMDB Scores Per Genre",
         deci = 1)
```

The graph above allows us to see that a less produced category, bibliography, possess the most positive ratings.

##### Genres VS Facebook Likes

Let's now have a look at the Facebook likes. 

```{r }

# plotting 10 highest rated genres 
bar_plot(arr_score[1:10,],
         arr_score[1:10,]$avg_facebook_likes,
         arr_score[1:10,]$avg_facebook_likes,
         "| Average Score:",
         "Genres",
         "Average Facebook Likes",
         "Top 10 Facebook Likes Per Genre",
         deci = 1)
```

Biography also produces the highest likes on facebook. From this information, should directors strive to create more biography's? This will be determined when looking at the ROI. 

### Popularity Analysis

IMDB ratings VS Movie Count

```{r }
ggplot(movie_metadata, aes(imdb_score)) +
 geom_histogram(bins = 50) +
 geom_vline(xintercept = mean(movie_metadata$imdb_score,na.rm = TRUE),colour = "blue") +
 ylab("Movie Count") +
 xlab("IMDB Rating") +
 ggtitle("IMDB Ratings for Movies") +
  ggplot2::annotate("text", label = "Mean IMDB rating",x = 6.2, y = 50, size = 3, colour = "yellow",angle=90)
```
It is evident from the histogram that the majority of movies are rated between 6-8 out of 10. If a movie has a lower rating, it is clearly very unpopular or very bad. If a movie has a higher rating, it is evidently fantastic.

Popularity over the years
```{r message=FALSE, }
#Creating the required subset of data 
movies_pop <- movie_metadata %>%
 select(title_year, movie_facebook_likes) %>%
 filter(title_year > 1980) %>%
 group_by(title_year) %>%
 summarise(avg = mean(movie_facebook_likes)) 

#Generating the popularity Vs time plot
 ggplot(movies_pop, aes(x = title_year, y = avg)) +
   geom_point() +
   geom_smooth() + 
   geom_vline(xintercept = c(1990,2004),colour = c("orange","blue")) +
   ylab("Mean Popularity Score") +
   xlab("Years") +
   ggplot2::annotate("text", label = "Facebook",x = 2003, y = 80, size = 3, colour = "blue",angle=90)+
   ggplot2::annotate("text", label = "IMDB",x = 1989, y = 80, size = 3, colour = "orange",angle=90)
```
<br>

A spike in popularity in 2004 is obvious owing to the fact that there is a clear rise in popularity score.The creation of facebook and the effect of social media influenced this. 

Facebook Likes VS IMDB Score
```{r}
movie_metadata %>%
  plot_ly(x = ~movie_facebook_likes, y = ~imdb_score, color = ~content_rating , mode = "markers", text = ~content_rating, alpha = 0.7, type = "scatter")
```
It is evident that as a movie has higher ratings, the number of likes on facebook increases. This is probably due to the fact that a critic giving a movie a good rating, will increase the want of people to see and find more out about the move. 

Top 20 directors with highest average IMDB score

When examinning the directors with the highest IMDB scores, the highest average rating is 8.4. This means that movies with higher ratings are either excellent and/or fluke occurences. 
```{r}
movie_metadata %>%
  group_by(director_name) %>%
  summarise(avg_imdb = mean(imdb_score)) %>%
  arrange(desc(avg_imdb)) %>%
  top_n(20, avg_imdb) %>%
  formattable(list(avg_imdb = color_bar("orange")), align = 'l')
```

The IMDB rating systen started in 1990’s. Social media platforms like Facebook had started in the mid 2000’s. Facebook influenced the number of rates per movie far higher than that of IMDB.
```{r}
#Performing operations on Movies Vote Count over the years
 movies_vote1 <- movie_metadata %>%
  select(title_year, num_voted_users) %>%
  group_by(title_year) %>%
  summarise(count = sum(num_voted_users)) 

 ggplot(movies_vote1, aes(x = title_year, y = count/1000)) +
   geom_bar( stat = "identity") +
   geom_vline(xintercept = c(1990,2004),colour = c("orange","blue")) +
   ylab("Vote count (in thousands)") +
   xlab("Years") +
   ggplot2::annotate("text", label = "Facebook",x = 2003, y = 160, size = 3, colour = "blue",angle=90) + 
   ggplot2::annotate("text", label = "IMDB",x = 1989, y = 160, size = 3, colour = "orange",angle=90)
```

Vote Counts VS IMDB score

```{r echo=T}
# breaking num_users_voted into 4 buckets 
movie_metadata$vote_bucket <- cut(movie_metadata$num_voted_users, 
                         c(0, 50000, 100000, 300000, 500000))
```


```{r  fig.height = 4, fig.width = 6, }
# plotting a boxplot for votes vs imdb_score  
bp <- na.omit(movie_metadata) %>% 
  ggplot(aes(x = vote_bucket, y = imdb_score)) +
  geom_boxplot(aes(fill = vote_bucket), alpha = 0.7,
               show.legend = F) +
  stat_summary(fun.y = mean, geom = "point",
               shape = 23) +
  coord_flip() +
  xlab("User Votes") +
  ylab("IMDB Score") +
  ggtitle("Box plot for User Votes vs IMDB Score") +
  theme_minimal() +
  theme(plot.title = element_text(size = 14, 
                                  color = "darkgrey",
                                  family = "Times"))
ggplotly(bp) %>%
  layout(margin = m, 
        xaxis = a, 
        yaxis = a,
        legend = list(orientation = "h", size = 4,
                       bgcolor = "#E2E2E2",
                       bordercolor = "darkgrey",
                       borderwidth = 1,
                       x = 0,
                       y = -0.3)) 
```

```{r warning=FALSE, include=FALSE, fig.height = 4, fig.width = 6,}
# creating a function called scatter_plot for
# plotting scatter plots using ggplot and plotly

scatter_plot <- function(x, y, xlabel, ylabel, title,
                         text1, text2, text3,
                         alpha = NULL){
  if(is.null(alpha)) alpha <- 0.4
  gp <- ggplot(data = movie_metadata, mapping = aes(x = x, y = y,
                                          text = paste(text1, x,
                                                       text2, y,
                                                       text3, movie_title)))
  plot <- gp + geom_point(position = "jitter", 
                          show.legend = F, shape = 21, 
                          stroke = .2, alpha = alpha) + 
    xlab(xlabel) +
    ylab(ylabel) +
    ggtitle(title) +
    theme_minimal() +
    theme(legend.position = "none",
          plot.title = element_text(size = 12, face = "bold", 
                                    family = "Times", 
                                    color = "darkgrey")) 
  
  ggplotly(plot, tooltip = "text") %>%
    layout(m, xaxis = a, yaxis = a)
}
```


```{r fig.height = 4, fig.width = 6, }
# scatter plot for user votes vs imdb score
scatter_plot(movie_metadata$num_voted_users, movie_metadata$imdb_score, 
     "User Votes",
     "IMDB Score",
     "Scatter plot for User Votes vs IMDB Score",
     "User Votes:",
     "<br>IMDB Score:",
     "<br>Title:",
     alpha = 0.3)
```
From the above scatter plot, it is evident that the majority of movie ratings are close to the 7.5 point. 

```{r message=FALSE, warning=FALSE, include=FALSE}
# creating a function for plotting plotly line graph for title_year
line_graph <- function(data, y, name){
 
  scat_p1 <- plot_ly(data, x = ~title_year, y = ~ y, 
             name = name, type = 'scatter', mode = 'lines',
             line = list(color = sample(brewer.pal(11, "Spectral"), 1))) %>%
  layout(xaxis = list(title = "Title Year", zeroline = F,
                      showline = F, 
                      showticklabels = T),
         yaxis = list(title = "Average Score"),
         title = "Line Graph for Avg Score/Avg Votes/Avg User Review by Title Year", 
         font = list(family = "Serif", color = "grey"),
         legend = list(orientation = "h", size = 6,
                       bgcolor = "#E2E2E2",
                       bordercolor = "darkgrey",
                       borderwidth = 1),
         margin = m)
  scat_p1
}
```


Each line represents an average, for the imdb score, votes and user review. 
```{r fig.height = 6, fig.width = 10, }


# creating a data frame for average score, avg votes and, avg user reviews
# by title year
scat_year_score <- movie_metadata %>%
  group_by(title_year) %>%
  summarise(count = n(),
            IMDB_Score = round(mean(imdb_score),1),
            avg_votes = mean(num_voted_users),
            avg_user_review = round(mean(num_user_for_reviews)))

# plotting line graph for Avg score by title year 
lp1 <- line_graph(scat_year_score, 
                  scat_year_score$IMDB_Score, 
                  "Average Score")

# plotting line graph for Avg votes by title year
lp2 <- line_graph(scat_year_score, 
                  scat_year_score$avg_votes, 
                  "Average Votes")

# plotting line graph for Avg reviews by title year
lp3 <- line_graph(scat_year_score,
                  scat_year_score$avg_user_review,
                  "Average User Review") 


subplot(lp1, lp2, lp3, nrows = 3, heights = c(0.33, 0.33, 0.33))

```


### Profit | Gross | Return of Interest

```{r }
budget <- movie_metadata %>%
  select(movie_title, budget) %>%
  arrange(desc(budget)) %>%
  head(15)

x <- ggplot(budget, aes(x = reorder(movie_title, -desc(budget)), y = budget/1000000)) +
  geom_bar( stat = "identity")+ 
  theme(axis.text.x=element_text(hjust=1))+
  ggtitle("Movie Budgets")+
  xlab("")+
  ylab("Budget (in Millions)") + 
  coord_flip()

rev <- movie_metadata %>%
  select(movie_title, gross) %>%
  arrange(desc(gross)) %>%
  head(15)

y <- ggplot(rev, aes(x = (reorder(movie_title, -desc(gross))), y = gross/1000000)) +
  geom_bar( stat = "identity")+ 
  theme(axis.text.x=element_text(hjust=1))+
  ggtitle("Movie Gross")+
  xlab("")+
  ylab("Gross (in Millions)") + 
  coord_flip() 

ggarrange(x, y,
          labels = c("A", "B"),
          ncol = 1, nrow = 2)
```

In the above graph, it is evident that the movies with the highest budgets, do not essentially mean that they will equate to a high gross profit. 

Most Successful Directors based on Profit
```{r }
#Top 20 most successful directors
movie_metadata %>%
        group_by(director_name) %>%
  mutate(profit = gross - budget)%>%
select(director_name, budget, gross, profit) %>%
na.omit() %>% 
summarise(films = n(), budget = sum(as.numeric(budget)), gross = sum(as.numeric(gross)), profit = sum(as.numeric(profit))) %>%
mutate(avg_per_film = profit/films) %>%
arrange(desc(avg_per_film)) %>% 
top_n(20, avg_per_film) %>%
ggplot( aes(x = films, y = avg_per_film/1000000)) + 
geom_point(size = 1, color = "blue") + 
geom_text_repel(aes(label = director_name), size = 3, color = "blue") + 
xlab("Number of Films") + ylab("Avg Profit $millions") + 
ggtitle("Most Successful Directors")
```

Looking at the most succesful directos, one can determine richer directors by singular succesful films, such as Tim Miller, or creating an array of succesful films with large budgets, such as James Cameron. 

Top 20 movies based on its Profit

```{r }
#Top 20 movies based on its Profit
movie_metadata %>% 
  filter(title_year %in% c(2000:2016)) %>%
  mutate(profit = gross - budget,
         return_on_investment_perc = (profit/budget)*100) %>%
  arrange(desc(profit)) %>% 
  top_n(20, profit) %>%
  ggplot(aes(x=budget/1000000, y=profit/1000000)) + 
  geom_point(size = 2) + 
  geom_smooth(size = 1) + 
  geom_text_repel(aes(label = movie_title), size = 3) + 
  xlab("Budget $million") + 
  ylab("Profit $million") + 
  ggtitle("20 Most Profitable Movies")
```
When assessing the top 20 movies based on profit, Avatar is in the highest profit region, regioning in a similar area to director James cameron.

Top 20 movies based on its Return on Investment
```{r }
#Top 20 movies based on its Return on Investment
movie_metadata %>% 
  filter(budget >100000) %>%
  mutate(profit = gross - budget,
         return_on_investment_perc = (profit/budget)*100) %>%
  arrange(desc(profit)) %>% 
  top_n(20, profit) %>%
  ggplot(aes(x=budget/1000000, y=return_on_investment_perc)) + 
  geom_point(size = 2) + 
  geom_smooth(size = 1) + 
  geom_text_repel(aes(label = movie_title), size = 3) + 
  xlab("Budget $million") + 
  ylab("Percent Return on Investment") + 
  ggtitle("20 Most Profitable Movies based on its Return on Investment")
```
Sucessful directors such as George Lucas also have profitable movies. 

### Further Analysis

#### Commercial success Vs Critical acclaim
```{r }
movie_metadata %>%
  top_n(15, profit) %>%
  ggplot(aes(x = imdb_score, y = gross/10^6, size = profit/10^6, color = content_rating)) + 
  geom_point() + 
  geom_hline(aes(yintercept = 600)) + 
  geom_vline(aes(xintercept = 7.75)) + 
  geom_text_repel(aes(label = movie_title), size = 4) +
  xlab("Imdb score") + 
  ylab("Gross money earned in million dollars") + 
  ggtitle("Commercial success Vs Critical acclaim") +
  ggplot2::annotate("text", x = 8.5, y = 700, label = "High ratings \n & High gross") +
  theme(plot.title = element_text(hjust = 0.5))
```
In the above graph we can compare content rating to the content rating inference as well as the higher grossing films with sucessful directors. 

#### Correlation Heatmap

```{r }
ggcorr(movie_metadata, label = TRUE, label_round = 2, label_size = 2.8, size = 2, hjust = .85) +
  ggtitle("Correlation Heatmap") +
  theme(plot.title = element_text(hjust = 0.5))
```

Based on the heatmap, we can see some high correlations (greater than 0.7) between predictors.

According to the highest correlation value 0.95, we find actor_1_facebook_likes is highly correlated with the cast_total_facebook_likes, and both actor2 and actor3 are also somehow correlated to the total. So we want to modify them into two variables: actor_1_facebook_likes and other_actors_facebook_likes.

There are high correlations among num_voted_users, num_user_for_reviews and num_critic_for_reviews.

#### Sentiment Analysis

```{r}
options(scipen = 999)
```

```{r}
IMDB <- read.csv("../data/real_deal.csv")

#Removing Duplicates
IMDB <- IMDB[!duplicated(IMDB), ]

#Removing White-Spaces and Special Characters
IMDB$movie_title <- gsub("Â", "", as.character(factor(IMDB$movie_title)))
IMDB$movie_title <- str_trim(IMDB$movie_title, side = "right")

IMDB <- subset(IMDB, select = -c(genres))

colSums(sapply(IMDB, is.na))
```

```{r }
#Plotting Facebook likes against IMDB score
ggplot(data = IMDB, aes(x = imdb_score, y = movie_facebook_likes)) +
  geom_point() +
  stat_smooth(method="lm")
```

From the above graph, it is evident that films with lower IMDB ratings can still have many facebooks likes. However, the majority of the facebook likes lie within the 6-8 region. 

```{r }
#Plotting Aspect Ratio against Facebook likes
IMDB %>% 
  filter(aspect_ratio==1.85 | aspect_ratio==2.35) %>%
  mutate(aspect_ratio=as.character((aspect_ratio))) %>%
  ggplot() +
  geom_point(aes(x=aspect_ratio, y=movie_facebook_likes))
```

From the above graph we can determine that users enjoy a higher aspect ratio on films. 

```{r}
#Constructing Top 20
keywords_split <- str_split(IMDB$plot_keywords, pattern="[|]", n=5)

keywords_matrix <- do.call(rbind, strsplit(as.character(IMDB$plot_keywords), "[|]"))

keywords_df <- as.data.frame(keywords_matrix)

names(keywords_df) <- c("one", "two", "three", "four", "five")

keywords_one_col <- gather(keywords_df) %>% 
  select(value)

keywords_one_col_freq <- keywords_one_col %>%
  group_by(value) %>%
  tally()

top_20 <- keywords_one_col_freq %>%
  select(value, n) %>%
  top_n(20)


movies_with_keywords <- data.frame()
IMDB_keyword_movie <- data.frame()
```


```{r }
keywords_one_col %>%
  group_by(value) %>% 
  tally() %>% 
  filter(n > 30) %>% 
  ggplot() +
  geom_bar(aes(x = value, y=n), stat="identity") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) 

top_20
```


```{r}
#Placing Top 20 Words Against Movie Success

IMDB_true_false <- IMDB 
for (keyword in top_20$value) {
  IMDB_true_false <- cbind(IMDB_true_false, ifelse(str_detect(IMDB$plot_keywords, keyword), "TRUE", "FALSE"))
}

for (i in 1:20) {
  reference <- 27
  names(IMDB_true_false)[reference + i] <- top_20$value[i]  
}

truey <- data.frame()
for (keyword in top_20$value) {
  truey <- rbind(truey, IMDB_true_false %>%
                            filter(get(keyword) == TRUE) %>% select(movie_title, gross, imdb_score, movie_facebook_likes, plot_keywords)) %>%
    distinct(movie_title, .keep_all = T)
}



falsy <- data.frame()
for (keyword in top_20$value) {
  falsy <- rbind(falsy, IMDB_true_false %>%
                            filter(get(keyword) == FALSE) %>% select(movie_title, gross, imdb_score, movie_facebook_likes, plot_keywords)) %>%
    distinct(movie_title, .keep_all = T)
}
```

```{r}
truey <- truey %>%
  mutate(tri = "Top 20 Word")

falsy <- falsy %>%
  mutate(tri = "NOT Top 20 Word")

truey_falsy <- full_join(falsy, truey, by = c("movie_title", "gross", "imdb_score", "movie_facebook_likes", "plot_keywords"))

truey_falsy <- truey_falsy %>%
  mutate(tri = coalesce(tri.y, tri.x)) %>%
  select(movie_title, gross, imdb_score, movie_facebook_likes, plot_keywords, tri)

truey_falsy <-  truey_falsy %>%
  group_by(tri) %>%
  na.omit() %>%
  mutate(avg = mean(gross))

truey_falsy_graph <- summarise(truey_falsy, avg = mean(gross))
```

```{r}
truey_falsy_graph %>%
  ggplot() +
  geom_bar(aes(x = tri, y=avg, fill=tri), stat="identity", position="stack") +
  theme(axis.text.x = element_blank()) 
```


```{r}
#Sentiment

keywords_from_split <- data.frame(lapply(keywords_split, "length<-", max(lengths(keywords_split))))

#Creating a list of titles and years seperatored by "|"
titles <-  IMDB %>%
  select(movie_title)
years <- IMDB %>%
  select(title_year)

titles_years_list <- list()

for (x in 1:4998) {
  seperator="|"
  titles_years_list <- c(titles_years_list, paste(titles$movie_title[x], years$title_year[x], sep="|"))
}

#Renaming columns to movie names
movie_name_list <- IMDB$movie_title
names(keywords_from_split) <- titles_years_list

#Adding column to the begining
key_names <- c('key_word_1', 'key_word_2', 'key_word_3', 'key_word_4', 'key_word_5')
keywords_from_split <- cbind(test_keys = key_names, keywords_from_split)

#Moving columns to rows
keywords_from_split <- melt(keywords_from_split, id = "test_keys")

#Creating new column for year
keywords_from_split_matrix <- do.call(rbind, strsplit(as.character(keywords_from_split$variable), "[|]"))
keywords_from_split <- cbind(keywords_from_split, keywords_from_split_matrix)
names(keywords_from_split) <- c("Key #", "Combined", "Keyword", "Title", "Year")
keywords_from_split = keywords_from_split %>%
  select(`Key #`, Title, Year, Keyword)

#Replacing blank cells within keywords to NA's
keywords_from_split$Keyword[keywords_from_split$Keyword == ""] <- NA
#Removing rows containing NA's
keywords_from_split <- na.omit(keywords_from_split)

#All unique years
all_years <- keywords_from_split %>% select(Year)
all_years <- distinct(all_years)
all_years <- na.omit(all_years)
all_years <- all_years %>%
  filter(Year != "NA")

#Function for sentiment per year
yearly_sentiment <- function(year, df) {
  amount <- nrow(df %>%
    select(Year) %>%
    filter(Year == year))
  df <- df %>%
    filter(Year == year)
  sentiments <- get_nrc_sentiment(as.character(df[4]))
  for (i in 1:length(sentiments)) {
    sentiments[i] <- sentiments[i]/amount
  }
  year_sentiment <- cbind(year, sentiments)
  return (year_sentiment)
}

sentiments <- data.frame()

#For-loop to capture all years
for (i in all_years$Year) {
  sentiments <- rbind(sentiments,yearly_sentiment(i, keywords_from_split))
}

#Making years integers
sentiments$year <- strtoi(sentiments$year)

#Sort by year
sentiments <- sentiments[with(sentiments, order(year)), ]
#sentiments <- sentiments[order(year), ]

#Heatmap for sentiments
rnames <- sentiments[,1]
mat_sentiments <- data.matrix(sentiments[,2:ncol(sentiments)])
rownames(mat_sentiments) <- rnames
mat_sentiments <- t(mat_sentiments)

df_sentiment <-  as.data.frame(mat_sentiments)
names_emotions <- c("anger", "anticipation", "disgust","fear","joy","sadness","surprise","trust","negative","positive")

sentiments_graph <- cbind(names_emotions, df_sentiment)
```


```{r}
#Run if there is a problem with heatmap
dev.off()

#Heatmap
heatmap.2(mat_sentiments, Rowv=NA, Colv=NA, scale="row", col=colorRampPalette(c("white","darkblue")),  margins=c(5,10), trace = "none")
```


```{r}
#Filtering sentiments graph
sentiments_graph_filter <- sentiments %>%
  filter(year >= 2000)

#Other graphs
# Showing trends between sentiment from the 2000's 
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = anger)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = anticipation)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = disgust)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = fear)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = joy)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = sadness)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = surprise)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = trust)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = negative)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
ggplot(sentiments_graph_filter, aes(x = as.numeric(year), y = positive)) + 
  geom_point(alpha = 0.5) + 
  geom_line()
```


-----

## Network Analysis









>>>>>>> 2b3e2e1584f68836b8a519ba7108e230d50f55d9
